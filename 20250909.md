# **数据结构第一次作业**

## （1）C++编程：分别使用递归以及循环两种方法实现斐波那契数列

```
#include <bits/stdc++.h>
using namespace std;

int Recursion(int i)
{
	if(i<=1)
		return 1;
	else
	{
		return Recursion(i-1)+Recursion(i-2);
	}
}

int Loop(int i)
{
	int temp,a,b;
	a=0;b=1;temp=1;
	while(i>1)
	{
		temp=a+b;a=b;b=temp;
		i--;
	}
	return temp;
}

int main()
{
	int i;
	cin>>i;
	cout<<Recursion(i);
	cout<<endl<<Loop(i);
}
```

### 复杂度分析：

对于递归算法Recursion函数，对于一个较大的n值，其每调用一次递归函数需要进行2次运算（line 6-11），总的时间复杂度为O（2^n）

对于循环函数Loop，对于一个较大的n值，其需要进行共n-1次循环(line 18)，其时间复杂度为O（n）

## （2）Exercise 2.7：运行时间分析（使用大O）

对于下列 6 个程序片段中的每一个：

a. 给出运行时间分析（使用大 O 即可）。
b. 用你选择的语言编程，并对 N 的几个具体值给出运行时间。
c. 用实际的运行时间与你的分析进行比较。

(1)

```
sum = 0;
     for( i = 0; i < n; ++i )
     ++sum;
```

只进行一次循环，O（n）

(2)

```
sum = 0;
for( i = 0; i < n; ++i )
    for( j = 0; j < n; ++j )
        ++sum;
```

外层循环与内层循环都是n次，共O（n^2)

(3)

```
sum = 0;
for( i = 0; i < n; ++i )
    for( j = 0; j < n * n; ++j )
        ++sum;
```

外层循环n次，内层循环n^2次，共O（n^3）

(4)

```
sum = 0;
for( i = 0; i < n; ++i )
    for( j = 0; j < i; ++j )
        ++sum;
```

外层循环n次，内层循环使用等差数列求和得到总操作次数为 0+1+2+⋯+(n−1)=n（n-1）/2，则总的时间复杂度为O（n^2）

(5)

```
sum = 0;
for( i = 0; i < n; ++i )
    for( j = 0; j < i * i; ++j )
        for( k = 0; k < j; ++k )
            ++sum;
```

最外层循环n次，中间层对于每一个i，循环ii次，而最内层循环进行j次，则利用级数求和，总操作次数大致为n（n+1）（2n-1）/2 *(n^2),则时间复杂度应为O（n^5）

(6)

```
sum = 0;
for( i = 1; i < n; ++i )
    for( j = 1; j < i * i; ++j )
        if( j % i == 0 )
            for( k = 0; k < j; ++k )
                ++sum;
```

最外层循环n-1次，对于每个i，中间层循环i^2-1次，而最内层循环大约j次（约等于i次），则利用级数求和，总的时间复杂度为O（n^3)

## (3)a. 编写一个程序来确定正整数 **N** 是否是素数。

```
#include <bits/stdc++.h>
using namespace std;

bool isPrime(int i)
{
	if(i<=1)
		return false;
	if(i<=3)
		return true;
	for(int n=2;n*n<=i;n++)
	{
		if(i%n==0)
			return false;
	}
	return true;
}

int main()
{
	int i;
	cin>>i;
	cout<<isPrime(i);
}
```

## b. 你的程序在最坏情形下的运行时间是多少 (用 **N** 表示)？(应该能够以 **\(O(\sqrt{N})\)** 来完成这项工作。)

对于一个足够大的N，根据循环的条件，最多需要sqrt（N）次循环就可以判断出n是不是素数

## c. 令 **B** 等于 **N** 的二进制表示法中的位数。**B** 的值是多少？

由二进制数的定义，B应该等于log以2为底N的对数向下取整+1

## d. 你的程序在最坏情形下的运行时间是什么 (用 **B** 表示)？

2^(B-1)

## e. 比较确定一个 20 (二进制) 位的数是否是素数和确定一个 40 (二进制) 位的数是否是素数的运行时间。

结合d的结论，时间差为2^10=1024倍

## f. 以 **N**，或者以 **B**，给出运行时间更合理吗？为什么？

B更合理，因为计算机是以二进制位来存储数据的，理论上也是以位来处理数据，因此用B给出运行时间理论上更合理
